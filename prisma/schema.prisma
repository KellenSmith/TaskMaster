generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider  = "postgresql"
    url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
    directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

model OrganizationSettings {
    id                 String  @id @default(uuid())
    organization_name  String  @default("Task Master")
    organization_email String  @default("kellensmith407@gmail.com")
    logo_url           String?

    remind_membership_expires_in_days    Int @default(7)
    purge_members_after_days_unvalidated Int @default(180)

    default_task_shift_length Int @default(2)

    member_application_prompt String?
    //TODO: configure fields for ticket instructions
    ticket_instructions       String?

    event_manager_email String? // If given, events must be approved by a manager before publishing

    @@map("organization_settings")
}

model TextContent {
    id           String            @id @default(uuid())
    category     String?           @default("organization") // ui, email, help, etc.
    translations TextTranslation[]

    @@map("text_contents")
}

enum Language {
    swedish
    english
}

model TextTranslation {
    id              String      @id @default(uuid())
    text            String
    language        Language
    text_content_id String
    text_content    TextContent @relation(fields: [text_content_id], references: [id])

    @@unique([language, text_content_id])
    @@map("text_translations")
}

enum UserRole {
    member
    admin
}

model User {
    id                     String   @id @default(uuid())
    email                  String   @unique
    nickname               String   @unique @default(uuid())
    role                   UserRole @default(member)
    consent_to_newsletters Boolean  @default(false)

    first_name String?
    sur_name   String?
    pronoun    String?  @default("they/them")
    phone      String?
    created_at DateTime @default(now())

    user_credentials UserCredentials?
    user_membership  UserMembership?

    hosting_events     Event[]
    participant_events EventParticipant[]
    reserve_events     EventReserve[]

    assigned_tasks Task[]           @relation("assignee")
    reviewer_tasks Task[]           @relation("reviewer")
    skill_badges   UserSkillBadge[]

    orders Order[]

    @@map("users") // Map to table named "users"
}

// No users can log in without credentials.
// Admins can validate membership to create credentials for user.
model UserCredentials {
    id              String @id @default(uuid())
    salt            String
    hashed_password String

    user    User   @relation(fields: [user_id], references: [id])
    user_id String @unique

    @@map("user_credentials")
}

model Location {
    id                 String  @id @default(uuid())
    name               String
    contact_person     String?
    rental_cost        Float   @default(0)
    address            String
    capacity           Int
    accessibility_info String?
    description        String?
    events             Event[]

    @@map("locations")
}

enum EventStatus {
    draft
    pending_approval
    published
    cancelled
}

model Event {
    id               String      @id @default(uuid())
    title            String      @default("")
    location_id      String?
    location         Location?   @relation(fields: [location_id], references: [id])
    start_time       DateTime
    end_time         DateTime
    description      String?
    max_participants Int
    status           EventStatus @default(draft)
    tags             String[]    @default([])

    // Must be optional to enable deleting users
    host    User?   @relation(fields: [host_id], references: [id])
    host_id String?

    event_reserves EventReserve[]
    tasks          Task[]
    tickets        Ticket[]

    @@map("events")
}

// Many-to-many relation btw users and events
// Each user can participate in multiple events
// Each event can have multiple participants
model EventParticipant {
    user      User   @relation(fields: [user_id], references: [id])
    user_id   String
    ticket    Ticket @relation(fields: [ticket_id], references: [id])
    ticket_id String // All participants must have a ticket

    // This combination is unique. A user can only have one ticket per event
    @@id([user_id, ticket_id])
    @@map("event_participants")
}

// Many-to-many relation btw users and events
// Each user can be on reserveList in multiple events
// Each event can have multiple reserve users
model EventReserve {
    user           User     @relation(fields: [user_id], references: [id])
    user_id        String
    event          Event    @relation(fields: [event_id], references: [id])
    event_id       String
    queueing_since DateTime @default(now())

    @@id([user_id, event_id])
    @@map("event_reserves")
}

/**
 * TODO: Implement handling:
 * Make a task card to show essentials when readonly
 * Handle task assignment separately from the task edit form
 * A rando can assign themself, eventhost or admin can assign others
 * When a task is assigned, move to inprogress.
 */
enum TaskStatus {
    toDo
    inProgress
    inReview
    done
}

model Task {
    id          String     @id @default(uuid())
    name        String
    status      TaskStatus @default(toDo)
    start_time  DateTime?
    end_time    DateTime
    description String?
    tags        String[]   @default([])

    assignee    User?   @relation("assignee", fields: [assignee_id], references: [id])
    assignee_id String?
    reviewer    User?   @relation("reviewer", fields: [reviewer_id], references: [id])
    reviewer_id String?

    event    Event?  @relation(fields: [event_id], references: [id])
    event_id String?

    skill_badges TaskSkillBadge[]

    @@map("tasks")
}

model SkillBadge {
    id                String           @id @default(uuid())
    name              String
    description       String?
    image_url         String?
    user_skill_badges UserSkillBadge[]
    task_skill_badges TaskSkillBadge[]

    @@map("skill_badges")
}

model UserSkillBadge {
    user           User       @relation(fields: [user_id], references: [id])
    user_id        String
    skill_badge    SkillBadge @relation(fields: [skill_badge_id], references: [id])
    skill_badge_id String

    @@id([user_id, skill_badge_id])
    @@map("user_skill_badges")
}

model TaskSkillBadge {
    task           Task       @relation(fields: [task_id], references: [id])
    task_id        String
    skill_badge    SkillBadge @relation(fields: [skill_badge_id], references: [id])
    skill_badge_id String

    @@id([task_id, skill_badge_id])
    @@map("task_skill_badges")
}

model Product {
    id              String  @id @default(uuid())
    name            String
    description     String?
    price           Float   @default(0)
    stock           Int?
    unlimited_stock Boolean @default(false)
    image_url       String?

    membership Membership?
    ticket     Ticket?

    order_items OrderItem[]

    @@map("products")
}

model Membership {
    id         String  @id @default(uuid())
    product    Product @relation(fields: [product_id], references: [id])
    product_id String  @unique
    duration   Int     @default(365) // in days

    users UserMembership[]

    @@map("memberships")
}

model UserMembership {
    id            String     @id @default(uuid())
    user          User       @relation(fields: [user_id], references: [id])
    user_id       String     @unique // One membership per user
    membership    Membership @relation(fields: [membership_id], references: [id])
    membership_id String

    expires_at DateTime

    @@map("user_memberships")
}

// Order of ticket types determines order of appearance in the ticket shop
enum TicketType {
    volunteer
    standard
}

model Ticket {
    id                 String             @id @default(uuid())
    type               TicketType         @default(standard)
    product            Product            @relation(fields: [product_id], references: [id])
    product_id         String             @unique
    event              Event              @relation(fields: [event_id], references: [id])
    event_id           String
    event_participants EventParticipant[]

    @@map("tickets")
}

// Defined in order of progression. Transitions backwards are never allowed
enum OrderStatus {
    pending
    paid
    shipped
    completed
    cancelled
    error
}

model Order {
    id                 String      @id @default(uuid())
    status             OrderStatus @default(pending)
    total_amount       Float       @default(0.0) // Total amount in the smallest currency unit (e.g., Ã¶re)
    payment_request_id String?     @unique
    payee_ref          String?     @unique // Reference to the payment provider's transaction

    created_at DateTime @default(now())
    updated_at DateTime @updatedAt

    // Must be optional to enable deleting users
    user    User?   @relation(fields: [user_id], references: [id])
    user_id String?

    order_items OrderItem[]

    @@map("orders")
}

model OrderItem {
    id       String @id @default(uuid())
    quantity Int    @default(1)
    price    Float  @default(0)

    order    Order  @relation(fields: [order_id], references: [id])
    order_id String

    product    Product @relation(fields: [product_id], references: [id])
    product_id String

    @@map("order_items")
}
